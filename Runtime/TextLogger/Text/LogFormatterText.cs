using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.IL2CPP.CompilerServices;
using Unity.Logging.Internal;
using Unity.Logging.Internal.Debug;
using Unity.Logging.Sinks;

namespace Unity.Logging
{
    /// <summary>
    /// Plain text formatter
    /// </summary>
    [BurstCompile]
    [Il2CppSetOption(Option.NullChecks, false)]
    [Il2CppSetOption(Option.ArrayBoundsChecks, false)]
    [Il2CppSetOption(Option.DivideByZeroChecks, false)]
    public static class LogFormatterText
    {
        private static FormatterStruct s_Formatter = default;

        /// <summary>
        /// FormatterStruct that can format text
        /// </summary>
        public static FormatterStruct Formatter
        {
            get
            {
                if (s_Formatter.IsCreated == false)
                {
                    s_Formatter = new FormatterStruct
                    {
                        OnFormatMessage = new OnLogMessageFormatterDelegate(OnLogMessageFormatterFunc),
                        UseText = true
                    };
                }

                return s_Formatter;
            }
        }

        /// <summary>
        /// Parses the LogMessage to UnsafeText
        /// </summary>
        /// <param name="messageData">LogMessage to parse</param>
        /// <param name="messageOutput">Memory to store the message</param>
        /// <param name="formatter">Formatter that sink is using</param>
        /// <param name="template">Template to use for the parsing</param>
        /// <param name="memoryManager">LogMemoryManager to get data from</param>
        /// <param name="userData">Not Used</param>
        /// <param name="allocator">If any memory allocation is needed - this allocator will be used</param>
        /// <returns>Length of the messageOutput. Negative on error</returns>
        [BurstCompile]
        [AOT.MonoPInvokeCallback(typeof(OnLogMessageFormatterDelegate.Delegate))]
        public static int OnLogMessageFormatterFunc(in LogMessage messageData, ref FormatterStruct formatter, ref FixedString512Bytes template, ref UnsafeText messageOutput, IntPtr memoryManager, IntPtr userData, Allocator allocator)
        {
            var errorMessage = default(FixedString512Bytes);

            if (template.IsEmpty)
            {
                SelfLog.OnEmptyTemplate();
                return 0;
            }
            ref var memAllocator = ref LogMemoryManager.FromPointer(memoryManager);

            var length = ParseMessage(ref template, in messageData, ref formatter, ref messageOutput, ref errorMessage, ref memAllocator);
            if (length < 0)
            {
                SelfLog.OnFailedToParseMessage();
            }
            return length;
        }

        /// <summary>
        /// Processes a TextLogger message and returns a text string containing the message text along with the context data referenced in the message.
        /// </summary>
        /// <remarks>
        /// This method is called by a TextLogger Sinks to extract the data from the message and generate a formatted text string, which can be written
        /// to an output stream. The message output is returned through a <see cref="UnsafeText"/> variable while any error messages are returned through
        /// a separate FixedString variable.
        ///
        /// The returned message string is allocated internally according to the size/length of the message, and therefore the caller should pass in an empty
        /// messageOutput variable. Furthermore, the string memory is allocated from the Temp pool and must not be referenced after the end of the frame. If
        /// the message needs to be held longer, it must be copied to a Persistent buffer. The caller should still Dispose the string once it's finished with it.
        ///
        /// If a problem occurs parsing/writing the output text, a separate errorMessage string is returned; a value of 'false' is returned in this case. Otherwise
        /// errorMessage string will be empty and 'true' is returned. Note that messageOutput may still hold valid text even if a error/failure occurs; it'll be
        /// a "partial" output string and missing some or all of the data.
        ///
        /// The caller must also pass in a reference to the <see cref="LogMemoryManager"/> instance holding the backing memory for the passed in <see cref="LogMessage"/>.
        /// Generally this is the MemoryManager within the <see cref="Logger"/> the Sink resides in.
        /// </remarks>
        /// <param name="template">Template for the message, like '{Timestamp} | {Level} | {Message}'</param>
        /// <param name="messageData">A <see cref="LogMessage"/> generated by the TextLogger to generated formatted output for.</param>
        /// <param name="formatter">Formatter that sink is using</param>
        /// <param name="messageOutput">Returns the text output generated from the log message.</param>
        /// <param name="errorMessage">Returns an error message string, should a problem parsing the message occur.</param>
        /// <param name="memAllocator">Reference to <see cref="LogMemoryManager"/> holding memory buffers for the passed in message.</param>
        /// <returns>messageOutput length or negative number if an error occurred.</returns>
        public static int ParseMessage(ref FixedString512Bytes template, in LogMessage messageData, ref FormatterStruct formatter, ref UnsafeText messageOutput, ref FixedString512Bytes errorMessage, ref LogMemoryManager memAllocator)
        {
            var lockContext = memAllocator.LockPayloadBuffer(messageData.Payload);
            if (lockContext.IsValid)
            {
                var success = ParseContextMessage(ref template, in messageData, ref formatter, ref messageOutput, ref errorMessage, ref memAllocator);

                memAllocator.UnlockPayloadBuffer(messageData.Payload, lockContext);

                if (success)
                    return messageOutput.Length;
                return -1;
            }

            messageOutput.Length = 0;
            errorMessage = Errors.FailedToLockPayloadBuffer;
            SelfLog.Error(errorMessage);

            return -2;
        }

        private static bool ParseContextMessage(ref FixedString512Bytes template, in LogMessage messageData, ref FormatterStruct formatter, ref UnsafeText messageOutput, ref FixedString512Bytes errorMessage, ref LogMemoryManager memAllocator)
        {
            messageOutput.Length = 0;

            var headerData = HeaderData.Parse(in messageData, ref memAllocator);

            if (headerData.Error != ErrorCodes.NoError)
            {
                SelfLog.Error(Errors.FromEnum(headerData.Error));
                return false;
            }

            var success = WriteTemplatedMessage(ref template, in messageData, ref formatter, ref headerData, ref messageOutput, ref errorMessage, ref memAllocator);

            // Regardless of current success value, if an error was raised return "failed"
            // NOTE: Internally we may return  "success" even when some errors are raised so as to continue parsing the message.
            if (!errorMessage.IsEmpty)
                success = false;

            return success;
        }

        /// <summary>
        /// Method that is used to parse the template, can contain {Message}
        /// </summary>
        /// <param name="template">Template that this sink is using</param>
        /// <param name="messageData">Log message</param>
        /// <param name="formatter">Current formatter</param>
        /// <param name="headerData">Parsed binary header data</param>
        /// <param name="messageOutput">Output of this function</param>
        /// <param name="errorMessage">Returns an error message string, should a problem parsing the message occur.</param>
        /// <param name="memAllocator">Memory allocator that contains other fields of the message</param>
        /// <returns>True if no errors happened</returns>
        private static bool WriteTemplatedMessage(ref FixedString512Bytes template, in LogMessage messageData, ref FormatterStruct formatter, ref HeaderData headerData, ref UnsafeText messageOutput, ref FixedString512Bytes errorMessage, ref LogMemoryManager memAllocator)
        {
            unsafe
            {
                byte* rawMsgBuffer = template.GetUnsafePtr();
                var currMsgSegment = new ParseSegment();

                bool success = true;
                bool done = false;
                do
                {
                    var result = MessageParser.FindNextParseStringSegment(in rawMsgBuffer, template.Length, ref currMsgSegment, out var currArgSlot);

                    success = messageOutput.Append(&rawMsgBuffer[currMsgSegment.Offset], currMsgSegment.Length) == FormatError.None && success;

                    switch (result)
                    {
                        case MessageParser.ParseContextResult.NoArgs:
                            done = true;
                            break;
                        case MessageParser.ParseContextResult.EscOpenBrace:
                        {
                            success = messageOutput.Append('{') == FormatError.None && success;
                            break;
                        }
                        case MessageParser.ParseContextResult.EscCloseBrace:
                        {
                            success = messageOutput.Append('}') == FormatError.None && success;
                            break;
                        }
                        case MessageParser.ParseContextResult.NormalArg:
                        {
                            var contextIndex = ArgumentInfo.RetrieveContextArgumentIndex(rawMsgBuffer, currArgSlot, isThisTemplate: true);
                            switch (contextIndex)
                            {
                                case ArgumentInfo.BuiltInNewLine:
                                    success = LogWriterUtils.WriteNewLine(ref messageOutput) && success;
                                    break;
                                case ArgumentInfo.BuiltInProperties:
                                    success = LogWriterUtils.WriteProperties(ref messageOutput) && success;
                                    break;
                                case ArgumentInfo.BuiltInLevelId:
                                    success = LogWriterUtils.WriteFormattedLevel(messageData.Level, ref messageOutput) && success;
                                    break;
                                case ArgumentInfo.BuiltInTimestampId:
                                    success = LogWriterUtils.WriteFormattedTimestamp(messageData.Timestamp, ref messageOutput) && success;
                                    break;
                                case ArgumentInfo.BuiltInMessage:
                                    success = WriteMessage(in messageData, ref formatter, ref headerData, ref messageOutput, ref errorMessage, ref memAllocator) && success;
                                    break;
                                case ArgumentInfo.BuiltInStackTrace:
                                    ManagedStackTraceWrapper.AppendToUnsafeText(messageData.StackTraceId, ref messageOutput);
                                    break;
                            }
                            break;
                        }
                    }

                    currMsgSegment.Offset = currArgSlot.Offset + currArgSlot.Length;
                    if (currMsgSegment.Offset >= template.Length)
                        done = true;
                }
                while (!done);

                return success;
            }
        }

        /// <summary>
        /// Method that is used to parse the {Message} itself
        /// </summary>
        /// <param name="logMessage">Log message</param>
        /// <param name="formatter">Current formatter</param>
        /// <param name="headerData">Parsed binary header data</param>
        /// <param name="messageOutput">Output of this function</param>
        /// <param name="errorMessage">Returns an error message string, should a problem parsing the message occur.</param>
        /// <param name="memAllocator">Memory allocator that contains other fields of the message</param>
        /// <returns>True if no errors happened</returns>
        public static bool WriteMessage(in LogMessage logMessage, ref FormatterStruct formatter, ref HeaderData headerData, ref UnsafeText messageOutput, ref FixedString512Bytes errorMessage, ref LogMemoryManager memAllocator)
        {
            unsafe
            {
                var rawMsgBuffer = headerData.MessageBufferPointer;
                var rawMsgBufferLength = headerData.MessageBufferLength;

                var currMsgSegment = new ParseSegment();
                var argIndexInString = -1;
                var done = false;
                var success = true;
                do
                {
                    var result = MessageParser.FindNextParseStringSegment(in rawMsgBuffer, in rawMsgBufferLength, ref currMsgSegment, out var currArgSlot);

                    success = messageOutput.Append(&rawMsgBuffer[currMsgSegment.Offset], currMsgSegment.Length) == FormatError.None && success;

                    switch (result)
                    {
                        case MessageParser.ParseContextResult.EscOpenBrace:
                        {
                            success = messageOutput.Append('{') == FormatError.None && success;
                            break;
                        }
                        case MessageParser.ParseContextResult.EscCloseBrace:
                        {
                            success = messageOutput.Append('}') == FormatError.None && success;
                            break;
                        }
                        case MessageParser.ParseContextResult.NormalArg:
                        {
                            var arg = ArgumentInfo.ParseArgument(rawMsgBuffer, currArgSlot.OffsetEnd, currArgSlot);

                            switch (arg.Type)
                            {
                                case ArgumentInfo.HoleType.UserDefined:
                                case ArgumentInfo.HoleType.BuiltinMessage:
                                {
                                    if (arg.IsValid)
                                    {
                                        ++argIndexInString;

                                        var contextIndex = arg.Index;
                                        if (arg.Name.IsEmpty == false)
                                        {
                                            contextIndex = argIndexInString;
                                        }

                                        if (headerData.TryGetContextPayload(contextIndex, out var payloadHandle))
                                        {
                                            success = LogWriterUtils.WriteFormattedContextData(ref formatter, payloadHandle, ref messageOutput, ref errorMessage, ref memAllocator, ref arg) && success;
                                        }
                                        else
                                        {
                                            errorMessage = Errors.UnableToRetrieveValidContextArgumentIndex;
                                            SelfLog.Error(errorMessage);

                                            success = false;
                                        }
                                    }
                                    else
                                    {
                                        // as a text
                                        success = messageOutput.Append(&rawMsgBuffer[currArgSlot.Offset], currArgSlot.Length) == FormatError.None && success;
                                    }

                                    break;
                                }
                                case ArgumentInfo.HoleType.BuiltinTimestamp:
                                {
                                    success = LogWriterUtils.WriteFormattedTimestamp(logMessage.Timestamp, ref messageOutput) && success;
                                    break;
                                }
                                case ArgumentInfo.HoleType.BuiltinLevel:
                                {
                                    success = LogWriterUtils.WriteFormattedLevel(logMessage.Level, ref messageOutput) && success;
                                    break;
                                }
                                case ArgumentInfo.HoleType.BuiltinStacktrace:
                                {
                                    ManagedStackTraceWrapper.AppendToUnsafeText(logMessage.StackTraceId, ref messageOutput);
                                    break;
                                }
                                case ArgumentInfo.HoleType.BuiltinNewLine:
                                {
                                    success = LogWriterUtils.WriteNewLine(ref messageOutput) && success;
                                    break;
                                }
                                case ArgumentInfo.HoleType.BuiltinProperties:
                                {
                                    success = LogWriterUtils.WriteProperties(ref messageOutput) && success;
                                    break;
                                }
                                default:
                                {
                                    errorMessage = Errors.UnableToRetrieveValidContextArgumentIndex;
                                    SelfLog.Error(errorMessage);
                                    success = false;
                                    break;
                                }
                            }
                            break;
                        }
                        case MessageParser.ParseContextResult.NoArgs:
                            done = true;
                            break;
                    }

                    currMsgSegment.Offset = currArgSlot.Offset + currArgSlot.Length;
                    if (currMsgSegment.Offset >= rawMsgBufferLength)
                        done = true;
                }
                while (!done);

                return success;
            }
        }
    }
}
